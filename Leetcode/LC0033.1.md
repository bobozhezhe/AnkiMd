# Leetcode

## 0033 Search in Curved Array

### Question

There is an integer array nums (may be duplicated values) that is sorted partially in ascending order and partially in descending order.

Find the index of the extreme point.

You must write an algorithm with O(log n) runtime complexity.

### Example 1

Input: nums = [4,5,5,6,7,2,1,1,0]
Output: 4

### Example 2

Input: nums = [0,1,2,7,7,6,5,4]
Output: 3

### Example 3

Input: nums = []
Output: -1

### Constraints

1 <= nums.length <= 5000
-10^4 <= nums[i] <= 10^4
Values of nums may be duplicated.
-104 <= target <= 10^4

%

### Key Point

1. 数值波形可能有4种：\, /, ^, v.
2. 用{head, head + 1}, {rear, rear - 1} 4个点来判定波形。
3. 二分查找，必有一半是单调的。单调为O(1)
4. 如果左无序，则右一定有序，判断target是否在右，在右则二分查找右，否则迭代查找左。

### Solution 1

// 递归实现

```java
class Solution {
    public int find_optimal(int[] nums) {
        int len = nums.length;

        if(len == 0) return -1;
        if(len == 1 || len == 2) return 0;
        if(len == 3) return nums[1];

        if(len == 4) {

        }

        boolean head_rising = nums[0] <= nums[1];
        boolean rear_rising = nums[len - 2] <= nums[len - 1];

        if(head_rising && rear_rising) // 单调增
            return nums[0];

        if(!head_rising && !rear_rising) // 单调减
            return nums[0];
        
        if(head_rising && !rear_rising) // ^ 型
            return find_peak(nums, 0, len - 1);

        if(!head_rising && rear_rising) // ^ 型
            return find_trough(nums, 0, len - 1);
    }

    private int find_peak(int[] nums, int l, int r) {
        // if mid 恰好是 peak
        return mid;

        // if 左侧单调 {在右侧找}
        find_peak(nums, mid, nums.length - 1);

        // if 右侧单调 {在左侧找}
        find_peak(nums, 0, mid);

    }
}

```
